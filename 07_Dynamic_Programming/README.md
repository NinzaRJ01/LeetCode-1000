# Dynamic Programming

## Introduction
Dynamic Programming (DP) is an algorithmic paradigm that solves complex problems by breaking them down into simpler subproblems. It stores the results of subproblems to avoid redundant computations.

## Types
1. Top-down (Memoization)
2. Bottom-up (Tabulation)
3. State Space Reduction
4. Digit DP
5. Probability DP
6. Tree DP

## Common Use Cases
1. Optimization Problems
2. Counting Problems
3. Path Finding
4. String Matching
5. Resource Allocation
6. Game Theory

## Time Complexity
- Depends on:
  - Number of states
  - Time per state
  - State transition
- Usually polynomial time
- Examples:
  - Fibonacci: O(n)
  - Knapsack: O(nW)
  - LCS: O(mn)

## Space Complexity
- Basic: O(n) or O(nÂ²)
- Space Optimization possible in many cases
- State compression techniques

## Common Patterns
1. Linear DP
2. Matrix Chain Multiplication
3. Interval DP
4. Tree DP
5. Bitmask DP
6. Subset DP

## Classic Problems
1. Longest Common Subsequence
2. 0/1 Knapsack
3. Edit Distance
4. Coin Change
5. Matrix Chain Multiplication
6. Longest Increasing Subsequence

## Optimization Techniques
1. State Reduction
2. Space Optimization
3. Divide and Conquer DP
4. Monotonic Queue Optimization
5. Convex Hull Optimization
